<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TensoricDoubleExpressions.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tensorics-core</a> &gt; <a href="index.source.html" class="el_package">org.tensorics.core.lang</a> &gt; <span class="el_source">TensoricDoubleExpressions.java</span></div><h1>TensoricDoubleExpressions.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2017 European Organisation for Nuclear Research (CERN), All Rights Reserved.
 */

package org.tensorics.core.lang;

import java.util.Comparator;

import org.tensorics.core.commons.operations.Conversion;
import org.tensorics.core.function.DiscreteFunction;
import org.tensorics.core.function.lang.FunctionExpressionSupportWithConversionAndComparator;
import org.tensorics.core.iterable.lang.OngoingDeferredIterableBinaryPredicate;
import org.tensorics.core.quantity.QuantifiedValue;
import org.tensorics.core.quantity.lang.OngoingDeferredQuantifiedScalarOperation;
import org.tensorics.core.scalar.lang.OngoingDeferredBinaryOperation;
import org.tensorics.core.scalar.lang.OngoingDeferredBinaryPredicate;
import org.tensorics.core.tensor.Tensor;
import org.tensorics.core.tensor.lang.OngoingDeferredQuantifiedTensorOperation;
import org.tensorics.core.tensor.lang.OngoingDeferredTensorOperation;
import org.tensorics.core.tensorbacked.Tensorbacked;
import org.tensorics.core.tensorbacked.lang.OngoingDeferredQuantifiedTensorBackedOperation;
import org.tensorics.core.tensorbacked.lang.OngoingDeferredTensorBackedOperation;
import org.tensorics.core.tree.domain.Expression;

<span class="nc" id="L25">public class TensoricDoubleExpressions {</span>

<span class="fc" id="L27">    private static final TensoricDoubleExpressionSupport EXPRESSION_SUPPORT = new TensoricDoubleExpressionSupport();</span>

    public static final Expression&lt;Double&gt; negativeOf(Expression&lt;Double&gt; element) {
<span class="nc" id="L30">        return EXPRESSION_SUPPORT.negativeOf(element);</span>
    }

    public final Expression&lt;Double&gt; averageOf(Iterable&lt;Double&gt; iterable) {
<span class="nc" id="L34">        return EXPRESSION_SUPPORT.averageOf(iterable);</span>
    }

    public static final Expression&lt;Double&gt; inverseOf(Expression&lt;Double&gt; element) {
<span class="nc" id="L38">        return EXPRESSION_SUPPORT.inverseOf(element);</span>
    }

    public static final Expression&lt;Double&gt; averageOf(Expression&lt;? extends Iterable&lt;Double&gt;&gt; iterableExpression) {
<span class="fc" id="L42">        return EXPRESSION_SUPPORT.averageOf(iterableExpression);</span>
    }

    public static final Expression&lt;Double&gt; sizeOf(Expression&lt;? extends Iterable&lt;?&gt;&gt; iterableExpression) {
<span class="fc" id="L46">        return EXPRESSION_SUPPORT.sizeOf(iterableExpression);</span>
    }

    public Expression&lt;Double&gt; squareRootOf(Expression&lt;Double&gt; value) {
<span class="nc" id="L50">        return EXPRESSION_SUPPORT.squareRootOf(value);</span>
    }

    public static final Expression&lt;Double&gt; sumOf(Expression&lt;? extends Iterable&lt;Double&gt;&gt; iterableExpression) {
<span class="fc" id="L54">        return EXPRESSION_SUPPORT.sumOf(iterableExpression);</span>
    }

    public Expression&lt;Double&gt; squareOf(Expression&lt;Double&gt; value) {
<span class="nc" id="L58">        return EXPRESSION_SUPPORT.squareOf(value);</span>
    }

    public static final OngoingDeferredTensorOperation&lt;Double&gt; calculateT(Expression&lt;Tensor&lt;Double&gt;&gt; tensoric) {
<span class="nc" id="L62">        return EXPRESSION_SUPPORT.calculateT(tensoric);</span>
    }

    public static final Expression&lt;Double&gt; rmsOf(Expression&lt;? extends Iterable&lt;Double&gt;&gt; iterableExpression) {
<span class="fc" id="L66">        return EXPRESSION_SUPPORT.rmsOf(iterableExpression);</span>
    }

    public static final OngoingDeferredBinaryOperation&lt;Double&gt; calculate(Expression&lt;Double&gt; left) {
<span class="nc" id="L70">        return EXPRESSION_SUPPORT.calculate(left);</span>
    }

    public static final Expression&lt;Double&gt; sumOfSquaresOf(Expression&lt;? extends Iterable&lt;Double&gt;&gt; iterableExpression) {
<span class="fc" id="L74">        return EXPRESSION_SUPPORT.sumOfSquaresOf(iterableExpression);</span>
    }

    public static final Expression&lt;Tensor&lt;Double&gt;&gt; elementInverseOf(Expression&lt;Tensor&lt;Double&gt;&gt; tensor) {
<span class="nc" id="L78">        return EXPRESSION_SUPPORT.elementInverseOf(tensor);</span>
    }

    public static final Expression&lt;Tensor&lt;Double&gt;&gt; elementNegativeOf(Expression&lt;Tensor&lt;Double&gt;&gt; tensor) {
<span class="nc" id="L82">        return EXPRESSION_SUPPORT.elementNegativeOf(tensor);</span>
    }

    public static final OngoingDeferredQuantifiedTensorOperation&lt;Double&gt; calculateQT(
            Tensor&lt;QuantifiedValue&lt;Double&gt;&gt; left) {
<span class="nc" id="L87">        return EXPRESSION_SUPPORT.calculate(left);</span>
    }

    public static final OngoingDeferredQuantifiedScalarOperation&lt;Double&gt; calculateQ(
            Expression&lt;QuantifiedValue&lt;Double&gt;&gt; scalar) {
<span class="nc" id="L92">        return EXPRESSION_SUPPORT.calculateQ(scalar);</span>
    }

    public static final &lt;TB extends Tensorbacked&lt;Double&gt;&gt; Expression&lt;TB&gt; elementNegativeOfTB(Expression&lt;TB&gt; tensor) {
<span class="nc" id="L96">        return EXPRESSION_SUPPORT.elementNegativeOfTB(tensor);</span>
    }

    public static final &lt;TB extends Tensorbacked&lt;Double&gt;&gt; OngoingDeferredTensorBackedOperation&lt;Double, TB&gt; calculateTB(
            Class&lt;TB&gt; resultClass, Expression&lt;TB&gt; tensoric) {
<span class="nc" id="L101">        return EXPRESSION_SUPPORT.calculateTB(resultClass, tensoric);</span>
    }

    public static final &lt;QTB extends Tensorbacked&lt;QuantifiedValue&lt;Double&gt;&gt;&gt; Expression&lt;QTB&gt; elementNegativeOfQTB(
            Class&lt;QTB&gt; resultClass, Expression&lt;QTB&gt; tensor) {
<span class="nc" id="L106">        return EXPRESSION_SUPPORT.elementNegativeOfQTB(resultClass, tensor);</span>
    }

    public static final &lt;TB extends Tensorbacked&lt;QuantifiedValue&lt;Double&gt;&gt;&gt; OngoingDeferredQuantifiedTensorBackedOperation&lt;Double, TB&gt; calculateQTB(
            Class&lt;TB&gt; resultClass, Expression&lt;TB&gt; tensor) {
<span class="nc" id="L111">        return EXPRESSION_SUPPORT.calculateQTB(resultClass, tensor);</span>
    }

    public static final OngoingDeferredBinaryPredicate&lt;Double&gt; testIf(Expression&lt;Double&gt; expression) {
<span class="nc" id="L115">        return EXPRESSION_SUPPORT.testIf(expression);</span>
    }

    public static final OngoingDeferredIterableBinaryPredicate&lt;Double&gt; testIfIt(
            Expression&lt;Iterable&lt;Double&gt;&gt; iterableExpression) {
<span class="nc" id="L120">        return EXPRESSION_SUPPORT.testIfIt(iterableExpression);</span>
    }

    public static final Expression&lt;Double&gt; rmsOfF(Expression&lt;DiscreteFunction&lt;Double, Double&gt;&gt; functionExpresssion) {
<span class="nc" id="L124">        return EXPRESSION_SUPPORT.rmsOfF(functionExpresssion);</span>
    }

    public static final Expression&lt;Double&gt; averageOfF(
            Expression&lt;DiscreteFunction&lt;Double, Double&gt;&gt; functionExpresssion) {
<span class="nc" id="L129">        return EXPRESSION_SUPPORT.averageOfF(functionExpresssion);</span>
    }

    public static final &lt;X&gt; FunctionExpressionSupportWithConversionAndComparator&lt;X, Double&gt; withConversionAndComparator(
            Conversion&lt;X, Double&gt; conversion, Comparator&lt;X&gt; comparator) {
<span class="nc" id="L134">        return EXPRESSION_SUPPORT.withConversionAndComparator(conversion, comparator);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>