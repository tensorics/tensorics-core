<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>InnerTensorOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tensorics-core</a> &gt; <a href="index.source.html" class="el_package">org.tensorics.core.tensor.operations</a> &gt; <span class="el_source">InnerTensorOperation.java</span></div><h1>InnerTensorOperation.java</h1><pre class="source lang-java linenums">// @formatter:off
 /*******************************************************************************
 *
 * This file is part of tensorics.
 *
 * Copyright (c) 2008-2011, CERN. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/
// @formatter:on

package org.tensorics.core.tensor.operations;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.Serializable;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.tensorics.core.commons.options.ManipulationOption;
import org.tensorics.core.commons.options.OptionRegistry;
import org.tensorics.core.commons.util.ValuePair;
import org.tensorics.core.iterable.operations.IterableOperation;
import org.tensorics.core.iterable.operations.IterableOperations;
import org.tensorics.core.lang.Tensorics;
import org.tensorics.core.math.Operations;
import org.tensorics.core.math.operations.BinaryOperation;
import org.tensorics.core.tensor.Position;
import org.tensorics.core.tensor.PositionPair;
import org.tensorics.core.tensor.Positions;
import org.tensorics.core.tensor.Positions.DimensionStripper;
import org.tensorics.core.tensor.Tensor;
import org.tensorics.core.tensor.TensorBuilder;
import org.tensorics.core.tensor.TensorPair;
import org.tensorics.core.tensor.options.BroadcastingStrategy;
import org.tensorics.core.tensor.options.ContextPropagationStrategy;
import org.tensorics.core.tensor.variance.CoContraDimensionPair;
import org.tensorics.core.tensor.variance.CoContraDimensionPairs;

import com.google.common.collect.ImmutableMultimap;
import com.google.common.collect.ListMultimap;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;

/**
 * Represents a binary operation on tensorics, respecting the equivalent of Einstein Summation Convention in tensorics
 * representation. The details are as follows:
 * &lt;p&gt;
 * Since every tensor within the tensorics framework, has to have unique classes for the tensor dimensions (equivalent
 * to the 'indizes' in a usual tensor notation), it is only possible to have at maximum one index (dimension) of the
 * same type in a tensor. Such coordinates are considered per default as contravariant coordinates (indizes). To
 * consistently describe a inner product it is necessary to have corresponding covariant indizes (dimensions in
 * tensorics). This can be achieved by using classes that are derived from the
 * {@link org.tensorics.core.tensor.variance.Covariant} class.
 * &lt;p&gt;
 * The most common of the type of operations, represented by this class, is the inner tensor product. However, this
 * operation is designed to be a bit more general, it uses two provided operations:
 * &lt;ul&gt;
 * &lt;li&gt;A binary operation on the type of the tensor values, by which the the elements of the two tensors are treated.
 * &lt;li&gt;An operation on iterables of the tensor values, which is used to reduce the tensor dimension, if applicable (see
 * below). NOTE: This operation must be associative, because it is performed in all directions at the same time. (The
 * user of this class has to take care about this, but it is currently not enforced by the class design).
 * &lt;/ul&gt;
 * Using these preconditions, this operation applies the following rules:
 * &lt;ol&gt;
 * &lt;li&gt;The usual broadcasting and shaping rules are applied (with a modification, which take care about the correct
 * mapping of co- and contravariant dimensions)
 * &lt;li&gt;The element-wise binary operation is applied on all the elements
 * &lt;li&gt;For each dimension, where there is a covariant version in one tensor and a contravariant version in the other
 * tensor, the reduction operation is applied. If one tensor contains both variants and the other only one, then the
 * order the operation still is uniquely defined and the order of the operands (left, right) does not matter. However,
 * if both tensors contain both variants, then the contravariant (default) dimension of the right tensor is reduced
 * together with the covariant dimension of the left tensor. This is equivalent (and can be memorized like) the usual
 * matrix multiplication.
 * &lt;li&gt;The result will always be contravariant
 * &lt;/ol&gt;
 *
 * @author kfuchsbe
 * @param &lt;V&gt;
 * @see org.tensorics.core.tensor.variance.Covariant
 * @see org.tensorics.core.tensor.variance.Covariants
 */
public class InnerTensorOperation&lt;V&gt; implements BinaryOperation&lt;Tensor&lt;V&gt;&gt;, Serializable {
    private static final long serialVersionUID = 1L;

    private final BinaryOperation&lt;V&gt; elementOperation;
    private final IterableOperation&lt;V&gt; reductionOperation;
    private final OptionRegistry&lt;ManipulationOption&gt; optionRegistry;

    public InnerTensorOperation(BinaryOperation&lt;V&gt; elementOperation, IterableOperation&lt;V&gt; reductionOperation,
            OptionRegistry&lt;ManipulationOption&gt; optionRegistry) {
<span class="fc" id="L105">        super();</span>
<span class="fc" id="L106">        this.elementOperation = elementOperation;</span>
<span class="fc" id="L107">        this.reductionOperation = reductionOperation;</span>
<span class="fc" id="L108">        this.optionRegistry = optionRegistry;</span>
<span class="fc" id="L109">    }</span>

    @Override
    public Tensor&lt;V&gt; perform(Tensor&lt;V&gt; left, Tensor&lt;V&gt; right) {
<span class="fc" id="L113">        checkNotNull(left, &quot;left tensor must not be null!&quot;);</span>
<span class="fc" id="L114">        checkNotNull(right, &quot;right tensor must not be null!&quot;);</span>

<span class="fc" id="L116">        List&lt;CoContraDimensionPair&gt; allPairs = CoContraDimensionPairs.coContraPairsOf(left.shape(), right.shape());</span>
<span class="fc" id="L117">        List&lt;CoContraDimensionPair&gt; pairsToReduce = CoContraDimensionPairs.chooseOnePerContravariantPart(allPairs);</span>
<span class="fc" id="L118">        Set&lt;Class&lt;?&gt;&gt; dimensionsNotToBroadcast = CoContraDimensionPairs.allDimensionsIn(pairsToReduce);</span>

<span class="fc" id="L120">        TensorPair&lt;V&gt; broadcasted = broadcast(left, right, dimensionsNotToBroadcast);</span>

<span class="fc" id="L122">        Set&lt;Class&lt;?&gt;&gt; leftDimensionsToReduce = CoContraDimensionPairs.leftDimensionsIn(pairsToReduce);</span>
<span class="fc" id="L123">        Set&lt;Class&lt;?&gt;&gt; rightDimensionsToReduce = CoContraDimensionPairs.rightDimensionsIn(pairsToReduce);</span>

<span class="fc" id="L125">        Set&lt;Class&lt;?&gt;&gt; remainingLeftDimensions = Sets</span>
<span class="fc" id="L126">                .difference(broadcasted.left().shape().dimensionSet(), leftDimensionsToReduce).immutableCopy();</span>
<span class="fc" id="L127">        Set&lt;Class&lt;?&gt;&gt; remainingRightDimensions = Sets</span>
<span class="fc" id="L128">                .difference(broadcasted.right().shape().dimensionSet(), rightDimensionsToReduce).immutableCopy();</span>

<span class="fc" id="L130">        Set&lt;Class&lt;?&gt;&gt; targetDimensions = Sets.union(remainingLeftDimensions, remainingRightDimensions).immutableCopy();</span>
<span class="fc" id="L131">        Set&lt;Class&lt;?&gt;&gt; remainingCommonDimensions = Sets.intersection(remainingLeftDimensions, remainingRightDimensions);</span>

        /*
         * produce a multimap from positions, consisting of all but the unique right dimensions to positions.
         */
<span class="fc" id="L136">        Set&lt;Class&lt;?&gt;&gt; uniqueLeftDimensions = Sets.difference(remainingLeftDimensions, remainingCommonDimensions);</span>
<span class="fc" id="L137">        Set&lt;Class&lt;?&gt;&gt; uniqueRightDimensions = Sets.difference(remainingRightDimensions, remainingCommonDimensions);</span>
<span class="fc" id="L138">        Multimap&lt;Position, Position&gt; nonUniqueToRightPositions = Positions</span>
<span class="fc" id="L139">                .mapByStripping(broadcasted.right().shape().positionSet(), uniqueRightDimensions);</span>

<span class="fc" id="L141">        DimensionStripper stripper = Positions.stripping(uniqueLeftDimensions);</span>

<span class="fc" id="L143">        DimensionStripper targetLeftStripper = Positions.stripping(leftDimensionsToReduce);</span>
<span class="fc" id="L144">        DimensionStripper targetRightStripper = Positions.stripping(rightDimensionsToReduce);</span>

<span class="fc" id="L146">        ImmutableMultimap.Builder&lt;Position, PositionPair&gt; builder = ImmutableMultimap.builder();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        for (Position leftPosition : broadcasted.left().shape().positionSet()) {</span>
<span class="fc" id="L148">            Position remainingLeftPosition = targetLeftStripper.apply(leftPosition);</span>

<span class="fc" id="L150">            Position nonUniqueLeftPosition = stripper.apply(leftPosition);</span>
<span class="fc" id="L151">            Position nonUniqueRightPosition = CoContraDimensionPairs.convertToRight(nonUniqueLeftPosition,</span>
                    pairsToReduce);
<span class="fc" id="L153">            Collection&lt;Position&gt; rightPositions = nonUniqueToRightPositions.get(nonUniqueRightPosition);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">            for (Position rightPosition : rightPositions) {</span>
<span class="fc" id="L155">                Position remainingRightPosition = targetRightStripper.apply(rightPosition);</span>
<span class="fc" id="L156">                Position targetPosition = Positions.combineDimensions(remainingLeftPosition, remainingRightPosition,</span>
                        targetDimensions);
<span class="fc" id="L158">                builder.put(targetPosition, PositionPair.fromLeftRight(leftPosition, rightPosition));</span>
<span class="fc" id="L159">            }</span>
<span class="fc" id="L160">        }</span>

<span class="fc" id="L162">        Multimap&lt;Position, PositionPair&gt; targetPositionToPairs = builder.build();</span>

<span class="fc" id="L164">        ListMultimap&lt;Position, ValuePair&lt;V&gt;&gt; valuePairs = broadcasted.mapValues(targetPositionToPairs);</span>

<span class="fc" id="L166">        ListMultimap&lt;Position, V&gt; targetPositionToValueSet = Operations.mapAll(valuePairs, elementOperation);</span>

<span class="fc" id="L168">        Map&lt;Position, V&gt; result = IterableOperations.reduce(targetPositionToValueSet, reductionOperation);</span>

<span class="fc" id="L170">        ContextPropagationStrategy cps = optionRegistry.get(ContextPropagationStrategy.class);</span>
<span class="fc" id="L171">        Position resultingContext = cps.contextForLeftRight(left.context(), right.context());</span>

<span class="fc" id="L173">        TensorBuilder&lt;V&gt; finalBuilder = Tensorics.builder(targetDimensions);</span>
<span class="fc" id="L174">        finalBuilder.putAll(result);</span>
<span class="fc" id="L175">        finalBuilder.context(resultingContext);</span>
<span class="fc" id="L176">        return finalBuilder.build();</span>
    }

    private TensorPair&lt;V&gt; broadcast(Tensor&lt;V&gt; left, Tensor&lt;V&gt; right, Set&lt;Class&lt;?&gt;&gt; dimensionsNotToBroadcast) {
<span class="fc" id="L180">        BroadcastingStrategy broadcasting = optionRegistry.get(BroadcastingStrategy.class);</span>
<span class="fc" id="L181">        return broadcasting.broadcast(left, right, dimensionsNotToBroadcast);</span>
    }

    @Override
    public int hashCode() {
<span class="nc" id="L186">        final int prime = 31;</span>
<span class="nc" id="L187">        int result = 1;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">        result = prime * result + ((elementOperation == null) ? 0 : elementOperation.hashCode());</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        result = prime * result + ((optionRegistry == null) ? 0 : optionRegistry.hashCode());</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">        result = prime * result + ((reductionOperation == null) ? 0 : reductionOperation.hashCode());</span>
<span class="nc" id="L191">        return result;</span>
    }

    @Override
    public boolean equals(Object obj) {
<span class="nc bnc" id="L196" title="All 2 branches missed.">        if (this == obj) {</span>
<span class="nc" id="L197">            return true;</span>
        }
<span class="nc bnc" id="L199" title="All 2 branches missed.">        if (obj == null) {</span>
<span class="nc" id="L200">            return false;</span>
        }
<span class="nc bnc" id="L202" title="All 2 branches missed.">        if (getClass() != obj.getClass()) {</span>
<span class="nc" id="L203">            return false;</span>
        }
<span class="nc" id="L205">        InnerTensorOperation&lt;?&gt; other = (InnerTensorOperation&lt;?&gt;) obj;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (elementOperation == null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (other.elementOperation != null) {</span>
<span class="nc" id="L208">                return false;</span>
            }
<span class="nc bnc" id="L210" title="All 2 branches missed.">        } else if (!elementOperation.equals(other.elementOperation)) {</span>
<span class="nc" id="L211">            return false;</span>
        }
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (optionRegistry == null) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">            if (other.optionRegistry != null) {</span>
<span class="nc" id="L215">                return false;</span>
            }
<span class="nc bnc" id="L217" title="All 2 branches missed.">        } else if (!optionRegistry.equals(other.optionRegistry)) {</span>
<span class="nc" id="L218">            return false;</span>
        }
<span class="nc bnc" id="L220" title="All 2 branches missed.">        if (reductionOperation == null) {</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">            if (other.reductionOperation != null) {</span>
<span class="nc" id="L222">                return false;</span>
            }
<span class="nc bnc" id="L224" title="All 2 branches missed.">        } else if (!reductionOperation.equals(other.reductionOperation)) {</span>
<span class="nc" id="L225">            return false;</span>
        }
<span class="nc" id="L227">        return true;</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L232">        return &quot;InnerTensorOperation [elementOperation=&quot; + elementOperation + &quot;, reductionOperation=&quot;</span>
                + reductionOperation + &quot;, optionRegistry=&quot; + optionRegistry + &quot;]&quot;;
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>