<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FieldInterpolator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tensorics-core</a> &gt; <a href="index.source.html" class="el_package">org.tensorics.core.tensor.resample.impl</a> &gt; <span class="el_source">FieldInterpolator.java</span></div><h1>FieldInterpolator.java</h1><pre class="source lang-java linenums">/**
 * Copyright (c) 2018 European Organisation for Nuclear Research (CERN), All Rights Reserved.
 */

package org.tensorics.core.tensor.resample.impl;

import static java.util.Objects.requireNonNull;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.Function;

import org.tensorics.core.math.ExtendedField;
import org.tensorics.core.scalar.lang.ScalarSupport;

/**
 * Takes a discrete set of x-values (being of type C - one coordinate of a tensor) and a transformation function of C to
 * V together with a callback function to Y values (of type V - the elements of a field) corresponding to the given X
 * values, and tries to determine a y-value for a given x-value by interpolating between the two neighbouring points.
 * The main purpose of this class is encapsulation for reusage and avoiding to avoid pass around a lot of parameters.
 * 
 * @author kfuchsbe
 * @param &lt;C&gt; the type of the coordinate (x-values)
 * @param &lt;V&gt; the type of the field elements (y-values of the 1-D discrete function to interpolate
 */
public class FieldInterpolator&lt;C, V&gt; extends ScalarSupport&lt;V&gt; {

    private Collection&lt;C&gt; coordinates;
    private Function&lt;C, V&gt; xConversion;
    private Function&lt;C, V&gt; yFunction;
    private C x;

    /**
     * Constructor, taking all the parameters required for the calculation
     * 
     * @param field the field of elements of type V, which is required to do the calculation for the interpolation and
     *            to have a comparator available.
     * @param coordinates the discrete set of coordinates, which represent the support points for the interpolation
     * @param xConversion a conversion function to convert x-values into the type V. This function has to be defined for
     *            each value of coordinates and x.
     * @param yFunction the function providing the y-values corresponding to each x-value. This function has to be
     *            defined for each value of coordinates (not for x, as otherwise interpolation would not be required).
     * @param x the point at which the y-value shall be determined.
     * @throws NullPointerException in case any of the given parameters is {@code null}
     */
    public FieldInterpolator(ExtendedField&lt;V&gt; field, Collection&lt;C&gt; coordinates, Function&lt;C, V&gt; xConversion,
            Function&lt;C, V&gt; yFunction, C x) {
<span class="fc" id="L52">        super(field);</span>
<span class="fc" id="L53">        this.coordinates = requireNonNull(coordinates, &quot;coordinates must not be null&quot;);</span>
<span class="fc" id="L54">        this.xConversion = requireNonNull(xConversion, &quot;XConversion must not be null&quot;);</span>
<span class="fc" id="L55">        this.yFunction = requireNonNull(yFunction, &quot;yFunction must not be null&quot;);</span>
<span class="fc" id="L56">        this.x = requireNonNull(x, &quot;x must not be null&quot;);</span>
<span class="fc" id="L57">    }</span>

    /**
     * Performs the actual calculation of interpolation.
     * 
     * @return the interpolated value at x
     */
    public V calculate() {
<span class="fc" id="L65">        return findNeigbouringX().interpolate();</span>
    }

    private TwoPointLinearInterpolation findNeigbouringX() {
<span class="fc" id="L69">        int size = coordinates.size();</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (size &lt; 2) {</span>
<span class="nc" id="L71">            throw new NoSuchElementException(</span>
                    &quot;Interpolation is not possible with less than 2 support points (&quot; + size + &quot; available).&quot;);
        }

<span class="fc" id="L75">        List&lt;C&gt; xValues = new ArrayList&lt;&gt;(coordinates);</span>
<span class="fc" id="L76">        Comparator&lt;C&gt; comparator = Comparator.comparing(xConversion, field().comparator());</span>

<span class="fc" id="L78">        Collections.sort(xValues, comparator);</span>

<span class="fc" id="L80">        C firstX = xValues.get(0);</span>
<span class="fc" id="L81">        C lastX = xValues.get(size - 1);</span>

<span class="fc bfc" id="L83" title="All 2 branches covered.">        boolean lessOrEqualThanFirstX = comparator.compare(x, firstX) &lt;= 0;</span>
<span class="fc bfc" id="L84" title="All 2 branches covered.">        boolean greaterOrEqualThanLastX = comparator.compare(x, lastX) &gt;= 0;</span>

<span class="fc" id="L86">        C x1 = null;</span>
<span class="fc" id="L87">        C x2 = null;</span>

<span class="fc bfc" id="L89" title="All 2 branches covered.">        if (lessOrEqualThanFirstX) {</span>
<span class="fc" id="L90">            x1 = firstX;</span>
<span class="fc" id="L91">            x2 = xValues.get(1);</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">        } else if (greaterOrEqualThanLastX) {</span>
<span class="fc" id="L93">            x1 = xValues.get(size - 2);</span>
<span class="fc" id="L94">            x2 = lastX;</span>
        } else {
<span class="fc" id="L96">            int index = 0;</span>

            do {
<span class="fc" id="L99">                x2 = xValues.get(index);</span>
<span class="fc" id="L100">                ++index;</span>
<span class="fc bfc" id="L101" title="All 2 branches covered.">            } while (comparator.compare(x2, x) &lt; 0);</span>

<span class="fc" id="L103">            x1 = xValues.get(index - 2);</span>
        }

<span class="fc" id="L106">        return new TwoPointLinearInterpolation(x1, x2);</span>
    }

    private class TwoPointLinearInterpolation {
        private final C x1;
        private final C x2;

<span class="fc" id="L113">        private TwoPointLinearInterpolation(C x1, C x2) {</span>
<span class="fc" id="L114">            this.x1 = x1;</span>
<span class="fc" id="L115">            this.x2 = x2;</span>
<span class="fc" id="L116">        }</span>

        private V interpolate() {
<span class="fc" id="L119">            V xMinusX1 = calculate(x(x)).minus(x(x1));</span>
<span class="fc" id="L120">            V x2MinusX1 = calculate(x(x2)).minus(x(x1));</span>
<span class="fc" id="L121">            V division = calculate(xMinusX1).dividedBy(x2MinusX1);</span>

<span class="fc" id="L123">            V y2MinusY1 = calculate(y(x2)).minus(y(x1));</span>
<span class="fc" id="L124">            V partialResult = calculate(division).times(y2MinusY1);</span>
<span class="fc" id="L125">            return calculate(partialResult).plus(y(x1));</span>

        }

        private V x(C xx) {
<span class="fc" id="L130">            return xConversion.apply(xx);</span>
        }

        private V y(C xx) {
<span class="fc" id="L134">            return yFunction.apply(xx);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>