<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Chains.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tensorics-core</a> &gt; <a href="index.source.html" class="el_package">org.tensorics.core.util.chains</a> &gt; <span class="el_source">Chains.java</span></div><h1>Chains.java</h1><pre class="source lang-java linenums">// @formatter:off
/**
*
* This file is part of streaming pool (http://www.streamingpool.org).
*
* Copyright (c) 2017-present, CERN. All rights reserved.
*
* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
// @formatter:on

package org.tensorics.core.util.chains;

import static java.util.Objects.requireNonNull;

import java.util.Objects;
import java.util.function.BiFunction;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;

import com.google.common.annotations.Beta;

@Beta
public final class Chains {

    private Chains() {
        /* Start clauses are only static methods */
    }

    public static &lt;R&gt; OngoingMainChain&lt;R&gt; chainFor(Class&lt;R&gt; returnClass) {
<span class="fc" id="L43">        return newFunctionBuilder(returnClass);</span>
    }

    private static &lt;R&gt; OngoingMainChain&lt;R&gt; newFunctionBuilder(Class&lt;R&gt; returnClass) {
<span class="fc" id="L47">        return new OngoingMainChain&lt;&gt;(returnClass);</span>
    }

    public abstract static class AbstractOngoingChain&lt;T, R, F, OC extends AbstractOngoingChain&lt;T, R, F, OC&gt;&gt; {

        private final Class&lt;R&gt; returnClass;

<span class="fc" id="L54">        AbstractOngoingChain(Class&lt;R&gt; returnClass) {</span>
<span class="fc" id="L55">            this.returnClass = Objects.requireNonNull(returnClass, &quot;returnClass must not be null&quot;);</span>
<span class="fc" id="L56">        }</span>

<span class="fc" id="L58">        @SuppressWarnings(&quot;unchecked&quot;)</span>
        OC castedThis = (OC) this;

        public OC or(Function&lt;? super T, R&gt; mapper) {
<span class="fc" id="L62">            builder().addMapper(mapper);</span>
<span class="fc" id="L63">            return castedThis;</span>
        }

        public OC or(BiFunction&lt;? super T, Function&lt;Object, R&gt;, R&gt; mapperWithCallback) {
<span class="nc" id="L67">            builder().addMapper(mapperWithCallback);</span>
<span class="nc" id="L68">            return castedThis;</span>
        }

        public OC matchCasesFrom(Class&lt;?&gt; caseBranchClass) {
<span class="nc" id="L72">            builder().addMapper(CaseMatchings.from(returnClass, caseBranchClass));</span>
<span class="nc" id="L73">            return castedThis;</span>
        }

        public &lt;CT&gt; OC matchCasesFrom(Class&lt;CT&gt; caseBranchClass, Supplier&lt;CT&gt; instanceCreator) {
<span class="nc" id="L77">            builder().addMapper(CaseMatchings.from(returnClass, caseBranchClass, instanceCreator));</span>
<span class="nc" id="L78">            return castedThis;</span>
        }

        public OngoingBranch&lt;T, T, R, OC&gt; branchIf(Predicate&lt;T&gt; condition) {
<span class="nc" id="L82">            return newBranchBuilder(condition, Function.identity());</span>
        }

        public &lt;T1&gt; OngoingBranch&lt;T, T1, R, OC&gt; branchIf(Predicate&lt;T&gt; condition, Function&lt;T, T1&gt; conversion) {
<span class="nc" id="L86">            return newBranchBuilder(condition, conversion);</span>
        }

        public &lt;T1 extends T&gt; OngoingBranch&lt;T, T1, R, OC&gt; branchCase(Class&lt;T1&gt; caseClass) {
<span class="nc" id="L90">            return newBranchBuilder(caseClass::isInstance, caseClass::cast);</span>
        }

        private &lt;T1&gt; OngoingBranch&lt;T, T1, R, OC&gt; newBranchBuilder(Predicate&lt;T&gt; condition, Function&lt;T, T1&gt; conversion) {
<span class="nc" id="L94">            return new OngoingBranch&lt;&gt;(returnClass, condition, conversion, new BranchChainBuilder&lt;&gt;(), castedThis);</span>
        }

        abstract AbstractChainBuilder&lt;T, R, F, ?&gt; builder();

    }

    public static class OngoingBranch&lt;PT, T, R, PB extends AbstractOngoingChain&lt;PT, R, ?, PB&gt;&gt;
            extends AbstractOngoingChain&lt;T, R, Branch&lt;T, R&gt;, OngoingBranch&lt;PT, T, R, PB&gt;&gt; {

        final BranchChainBuilder&lt;T, R&gt; builder;
        final PB parentChain;
        final Predicate&lt;PT&gt; condition;
        final Function&lt;PT, T&gt; conversion;

        OngoingBranch(Class&lt;R&gt; returnClass, Predicate&lt;PT&gt; condition, Function&lt;PT, T&gt; conversion,
                BranchChainBuilder&lt;T, R&gt; delegate, PB parentBuilder) {
<span class="nc" id="L111">            super(returnClass);</span>
<span class="nc" id="L112">            this.condition = requireNonNull(condition, &quot;condition must not be null&quot;);</span>
<span class="nc" id="L113">            this.conversion = requireNonNull(conversion, &quot;conversion must not be null&quot;);</span>
<span class="nc" id="L114">            this.builder = requireNonNull(delegate, &quot;delegate must not be null&quot;);</span>
<span class="nc" id="L115">            this.parentChain = requireNonNull(parentBuilder, &quot;parentBuilder must not be null&quot;);</span>
<span class="nc" id="L116">        }</span>

        public OngoingBranch&lt;PT, T, R, PB&gt; then(Function&lt;? super T, R&gt; mapper) {
<span class="nc" id="L119">            builder.addMapper(mapper);</span>
<span class="nc" id="L120">            return this;</span>
        }

        public OngoingBranch&lt;PT, T, R, PB&gt; then(BiFunction&lt;? super T, Function&lt;Object, R&gt;, R&gt; mapperWithCallback) {
<span class="nc" id="L124">            builder.addMapper(mapperWithCallback);</span>
<span class="nc" id="L125">            return this;</span>
        }

        public PB orElseThrow() {
<span class="nc" id="L129">            parentChain.builder().addConditionedMapper(condition, conversion, builder.orElseThrow().build());</span>
<span class="nc" id="L130">            return parentChain;</span>
        }

        public PB orElseFallThrough() {
<span class="nc" id="L134">            parentChain.builder().addConditionedMapper(condition, conversion, builder.orElseNull().build());</span>
<span class="nc" id="L135">            return parentChain;</span>
        }

        public PB orElseBreakWith(R returnValue) {
<span class="nc" id="L139">            requireNonNull(returnValue, &quot;the returnValue must not be null. &quot;</span>
                    + &quot;In case you want explicitely to fall through to the next branch use 'orElseFallThrough()' method&quot;);
<span class="nc" id="L141">            parentChain.builder().addConditionedMapper(condition, conversion, builder.orElse(returnValue).build());</span>
<span class="nc" id="L142">            return parentChain;</span>
        }

        @Override
        AbstractChainBuilder&lt;T, R, Branch&lt;T, R&gt;, ?&gt; builder() {
<span class="nc" id="L147">            return this.builder;</span>
        }

    }

    public static class OngoingMainChain&lt;R&gt; extends AbstractOngoingChain&lt;Object, R, Chain&lt;R&gt;, OngoingMainChain&lt;R&gt;&gt; {

<span class="fc" id="L154">        private final MainChainBuilder&lt;R&gt; builder = new MainChainBuilder&lt;&gt;();</span>

        OngoingMainChain(Class&lt;R&gt; returnClass) {
<span class="fc" id="L157">            super(returnClass);</span>
<span class="fc" id="L158">        }</span>

        public OngoingMainChain&lt;R&gt; endRecursionWith(Function&lt;Object, R&gt; newEndRecursionFunction) {
<span class="nc" id="L161">            this.builder.endRecursionWith(newEndRecursionFunction);</span>
<span class="nc" id="L162">            return this;</span>
        }

        public OngoingMainChain&lt;R&gt; endRecursionDefaultDepth(int newDefaultEndRecursionDepth) {
<span class="nc" id="L166">            this.builder.endRecursionAtDepth(newDefaultEndRecursionDepth);</span>
<span class="nc" id="L167">            return this;</span>
        }

        public OngoingMainChain&lt;R&gt; either(Function&lt;Object, R&gt; mapper) {
<span class="fc" id="L171">            builder.addMapper(mapper);</span>
<span class="fc" id="L172">            return castedThis;</span>
        }

        public OngoingMainChain&lt;R&gt; either(BiFunction&lt;Object, Function&lt;Object, R&gt;, R&gt; mapperWithCallback) {
<span class="fc" id="L176">            builder.addMapper(mapperWithCallback);</span>
<span class="fc" id="L177">            return castedThis;</span>
        }

        public Chain&lt;R&gt; orElseThrow() {
<span class="fc" id="L181">            return builder.orElseThrow().build();</span>
        }

        public Chain&lt;R&gt; orElseNull() {
<span class="fc" id="L185">            return builder.orElseNull().build();</span>
        }

        public Chain&lt;R&gt; orElse(R returnValue) {
<span class="nc" id="L189">            requireNonNull(returnValue,</span>
                    &quot;returnValue must not be null. In case, use explicitely the 'orElseNull()' method&quot;);
<span class="nc" id="L191">            return builder.orElse(returnValue).build();</span>
        }

        @Override
        AbstractChainBuilder&lt;Object, R, Chain&lt;R&gt;, ?&gt; builder() {
<span class="fc" id="L196">            return this.builder;</span>
        }

    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>