<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoContraDimensionPairs.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tensorics-core</a> &gt; <a href="index.source.html" class="el_package">org.tensorics.core.tensor.variance</a> &gt; <span class="el_source">CoContraDimensionPairs.java</span></div><h1>CoContraDimensionPairs.java</h1><pre class="source lang-java linenums">// @formatter:off
 /*******************************************************************************
 *
 * This file is part of tensorics.
 * 
 * Copyright (c) 2008-2011, CERN. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 ******************************************************************************/
// @formatter:on

package org.tensorics.core.tensor.variance;

import static com.google.common.base.Preconditions.checkState;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.tensorics.core.tensor.Position;
import org.tensorics.core.tensor.Shape;

import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSetMultimap;
import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;

/**
 * Provides utility methods related to {@link CoContraDimensionPair}s and collections of them.
 * 
 * @author kfuchsbe
 */
public final class CoContraDimensionPairs {

    /**
     * Private constructor to avoid instantiation
     */
    private CoContraDimensionPairs() {
        /* only static methods */
    }

    public static Set&lt;Class&lt;?&gt;&gt; rightDimensionsIn(Iterable&lt;CoContraDimensionPair&gt; pairs) {
<span class="fc" id="L57">        ImmutableSet.Builder&lt;Class&lt;?&gt;&gt; builder = ImmutableSet.builder();</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        for (CoContraDimensionPair pair : pairs) {</span>
<span class="fc" id="L59">            builder.add(pair.right());</span>
<span class="fc" id="L60">        }</span>
<span class="fc" id="L61">        return builder.build();</span>
    }

    public static Set&lt;Class&lt;?&gt;&gt; leftDimensionsIn(Iterable&lt;CoContraDimensionPair&gt; pairs) {
<span class="fc" id="L65">        ImmutableSet.Builder&lt;Class&lt;?&gt;&gt; builder = ImmutableSet.builder();</span>
<span class="fc bfc" id="L66" title="All 2 branches covered.">        for (CoContraDimensionPair pair : pairs) {</span>
<span class="fc" id="L67">            builder.add(pair.left());</span>
<span class="fc" id="L68">        }</span>
<span class="fc" id="L69">        return builder.build();</span>
    }

    /**
     * Collects all the dimensions that are contained in at least one of the given pairs, as either left or right
     * dimension.
     * 
     * @param pairs the pairs from which to retrieve the dimensions
     * @return all the dimensions which are involved in at least one of the sets
     */
    public static Set&lt;Class&lt;?&gt;&gt; allDimensionsIn(Iterable&lt;CoContraDimensionPair&gt; pairs) {
<span class="fc" id="L80">        return Sets.union(leftDimensionsIn(pairs), rightDimensionsIn(pairs)).immutableCopy();</span>
    }

    public static Map&lt;Class&lt;?&gt;, Collection&lt;CoContraDimensionPair&gt;&gt; mapOutByContravariantPart(
            List&lt;CoContraDimensionPair&gt; allPairs) {
<span class="fc" id="L85">        ImmutableSetMultimap.Builder&lt;Class&lt;?&gt;, CoContraDimensionPair&gt; builder = ImmutableSetMultimap.builder();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        for (CoContraDimensionPair pair : allPairs) {</span>
<span class="fc" id="L87">            builder.putAll(pair.contravariant(), pair);</span>
<span class="fc" id="L88">        }</span>
<span class="fc" id="L89">        return builder.build().asMap();</span>
    }

    /**
     * Searches in the two given shapes for dimensions that form pairs of co- and contravariant dimensions. This means
     * that the dimension is either covariant in the left shape and contravariant in the right or the other way around.
     * 
     * @param left the left shape of an operation that involves co- contravariant coordinates
     * @param right the right shape of an operation that involves co- and contravariant coordinates
     * @return a (unfiltered) list of pairs of coordinates, that have have co- and contravariant matches in both shapes.
     */
    public static List&lt;CoContraDimensionPair&gt; coContraPairsOf(Shape left, Shape right) {
<span class="fc" id="L101">        List&lt;CoContraDimensionPair&gt; pairs = new ArrayList&lt;&gt;();</span>

<span class="fc bfc" id="L103" title="All 2 branches covered.">        for (Class&lt;?&gt; leftDimension : left.dimensionSet()) {</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">            for (Class&lt;?&gt; rightDimension : right.dimensionSet()) {</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">                if (Covariants.isCoContraPair(leftDimension, rightDimension)) {</span>
<span class="fc" id="L106">                    pairs.add(CoContraDimensionPair.ofLeftRight(leftDimension, rightDimension));</span>
                }
<span class="fc" id="L108">            }</span>
<span class="fc" id="L109">        }</span>

<span class="fc" id="L111">        return pairs;</span>
    }

    /**
     * Choses one pair for a type of dimension to use. The current algorithm is:
     * &lt;ul&gt;
     * &lt;li&gt;If only one pair is available (how it should be in most cases), then this one is returned.
     * &lt;li&gt;If two are present, then the one which is covariant on the left is preferred
     * &lt;li&gt;If none is contained in the collection or none which is covariant in the left shape, then an exception is
     * thrown (This is an inconsistent state!)
     * &lt;/ul&gt;
     * 
     * @param pairsForOneDimension the pairs from which to choose one
     * @return one pair to use for that dimension
     */
    private static CoContraDimensionPair choose(Collection&lt;CoContraDimensionPair&gt; pairsForOneDimension) {
<span class="pc bpc" id="L127" title="1 of 2 branches missed.">        checkState(!pairsForOneDimension.isEmpty(),</span>
                &quot;No pairs of dimension found for one dimension-type. &quot; + &quot;Must be some wrong call to this method.&quot;);
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (pairsForOneDimension.size() == 1) {</span>
<span class="fc" id="L130">            return Iterables.getFirst(pairsForOneDimension, null);</span>
        }

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        checkState(pairsForOneDimension.size() &lt;= 2, &quot;More then 2 matching co- contravariant dimension found &quot;</span>
                + &quot;for the same contravariant dimension. This should not be possible!?&quot;);
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">        for (CoContraDimensionPair pair : pairsForOneDimension) {</span>
<span class="pc bpc" id="L136" title="1 of 2 branches missed.">            if (Covariants.isCovariant(pair.left())) {</span>
<span class="fc" id="L137">                return pair;</span>
            }
<span class="nc" id="L139">        }</span>
<span class="nc" id="L140">        throw new IllegalStateException(&quot;No valid dimension pair could be found within the collection.&quot;);</span>
    }

    private static List&lt;CoContraDimensionPair&gt; chooseOnePerContravariantPart(
            Map&lt;Class&lt;?&gt;, Collection&lt;CoContraDimensionPair&gt;&gt; contravariantToPairMap) {
<span class="fc" id="L145">        List&lt;CoContraDimensionPair&gt; toReturn = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">        for (Collection&lt;CoContraDimensionPair&gt; pairsForOneDimension : contravariantToPairMap.values()) {</span>
<span class="fc" id="L147">            CoContraDimensionPair chosenPair = choose(pairsForOneDimension);</span>
<span class="fc" id="L148">            toReturn.add(chosenPair);</span>
<span class="fc" id="L149">        }</span>
<span class="fc" id="L150">        return toReturn;</span>
    }

    /**
     * Filters the list of pairs in such a way, that only one per contravariant type remains.
     * 
     * @param allPairs the pairs to filter
     * @return a list containing only those, which in the end shall be used
     */
    public static List&lt;CoContraDimensionPair&gt; chooseOnePerContravariantPart(List&lt;CoContraDimensionPair&gt; allPairs) {
<span class="fc" id="L160">        return chooseOnePerContravariantPart(mapOutByContravariantPart(allPairs));</span>
    }

    public static Position convertToRight(Position position, List&lt;CoContraDimensionPair&gt; dimensionPairs) {
<span class="fc" id="L164">        Set&lt;Object&gt; convertedCoordinates = new HashSet&lt;&gt;();</span>
<span class="fc" id="L165">        Set&lt;?&gt; remainingCoordinates = new HashSet&lt;&gt;(position.coordinates());</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (CoContraDimensionPair dimensionPair : dimensionPairs) {</span>
<span class="fc" id="L167">            Object coordinate = position.coordinateFor(dimensionPair.left());</span>
<span class="fc" id="L168">            convertedCoordinates.add(dimensionPair.toRight(coordinate));</span>
<span class="fc" id="L169">            remainingCoordinates.remove(coordinate);</span>
<span class="fc" id="L170">        }</span>
<span class="fc" id="L171">        convertedCoordinates.addAll(remainingCoordinates);</span>
<span class="fc" id="L172">        return Position.of(convertedCoordinates);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>