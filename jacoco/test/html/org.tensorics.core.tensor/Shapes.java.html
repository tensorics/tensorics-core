<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Shapes.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tensorics-core</a> &gt; <a href="index.source.html" class="el_package">org.tensorics.core.tensor</a> &gt; <span class="el_source">Shapes.java</span></div><h1>Shapes.java</h1><pre class="source lang-java linenums">// @formatter:off
 /*******************************************************************************
 *
 * This file is part of tensorics.
 * 
 * Copyright (c) 2008-2011, CERN. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * 
 ******************************************************************************/
// @formatter:on

package org.tensorics.core.tensor;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;
import static com.google.common.collect.Collections2.transform;
import static java.util.Objects.requireNonNull;

import java.util.NoSuchElementException;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.function.Function;

import com.google.common.collect.Iterables;
import com.google.common.collect.Sets;

/**
 * Contains utility methods to deal with tensor shapes.
 * 
 * @author kfuchsbe
 */
public final class Shapes {

    /**
     * Private constructor to avoid instantiation
     */
    private Shapes() {
        /* Only static methods */
    }

    /**
     * Creates a shape, containing all the positions that are contained in both given shapes. This only makes sense, if
     * the dimensions of the two shapes are compatible. If they are not, then an {@link IllegalArgumentException} is
     * thrown.
     * 
     * @param left the first shape from which to take positions
     * @param right the second shape from which to take positions
     * @return a shape containing all positions, which are contained in both given shapes
     */
    public static Shape intersection(Shape left, Shape right) {
<span class="fc" id="L62">        return combineLeftRightBy(left, right, Sets::intersection);</span>
    }

    /**
     * Creates a shape, containing all the positions that are either contained in the left or the right shape.This only
     * makes sense, if the dimensions of the two shapes are the same. If they are not, then an
     * {@link IllegalArgumentException} is thrown.
     * 
     * @param left the first shape from which to take positions
     * @param right the second shape from which to take positions
     * @return a shape containing all positions, which are contained in at least one of the two shapes
     */
    public static Shape union(Shape left, Shape right) {
<span class="fc" id="L75">        return combineLeftRightBy(left, right, Sets::union);</span>
    }

    /**
     * Creates a shape, containing all the positions that are contained at least in one of the given shapes. This only
     * makes sense, if the dimensions of the shapes are compatible. If they are not, then an
     * {@link IllegalArgumentException} is thrown. Further, it is required that at least one element is contained in the
     * iterable.
     * 
     * @param shapes the shapes for which the union shall be found
     * @return a shape which represents the union of all the shapes
     * @throws IllegalArgumentException if the shapes are not of the same dimension
     * @throws NoSuchElementException in case the iterable is empty
     * @throws NullPointerException if the given iterable is {@code null}
     */
    public static final Shape union(Iterable&lt;Shape&gt; shapes) {
<span class="nc" id="L91">        return combineBy(shapes, Shapes::union);</span>
    }

    /**
     * Creates a shape, containing the positions which are contained in each of the given shapes. This only makes sense,
     * if the dimensions of the shapes are the same. If they are not, then an {@link IllegalArgumentException} is
     * thrown. Further, it is required that at least one element is contained in the iterable.
     * 
     * @param shapes the shapes for which the intersection shall be found
     * @return a shape which represents the intersection of all the shapes
     * @throws IllegalArgumentException if the shapes are not of the same dimension
     * @throws NoSuchElementException in case the iterable is empty
     * @throws NullPointerException if the given iterable is {@code null}
     */
    public static final Shape intersection(Iterable&lt;Shape&gt; shapes) {
<span class="nc" id="L106">        return combineBy(shapes, Shapes::intersection);</span>
    }

    /**
     * Extracts those dimensions, which are contained in both shapes.
     * 
     * @param left the first shape for which to look at the dimensions
     * @param right the second shape where to look at the dimensions.
     * @return all the dimensions which are present in both shapes
     */
    public static Set&lt;Class&lt;?&gt;&gt; dimensionalIntersection(Shape left, Shape right) {
<span class="fc" id="L117">        checkLeftRightNotNull(left, right);</span>
<span class="fc" id="L118">        return Sets.intersection(left.dimensionSet(), right.dimensionSet());</span>
    }

    public static Set&lt;Class&lt;?&gt;&gt; parentDimensionalIntersection(Shape left, Shape right) {
<span class="fc" id="L122">        checkLeftRightNotNull(left, right);</span>
<span class="fc" id="L123">        return Coordinates.parentClassIntersection(left.dimensionSet(), right.dimensionSet());</span>
    }

    /**
     * Constructs a shape that contains positions, which are derived from the positions of the given shape by stripping
     * (removing) the given dimensions. The returned shape contains then only unique resulting position-parts and thus
     * might be much smaller than the original shape.
     * 
     * @param shape the shape from which to extract the stripped positions
     * @param dimensionsToStrip the dimensions which shall be removed from the positions of the shape
     * @return a shape containing unique positions, resulting from the shapes positions, stripping the given dimensions
     * @throws NullPointerException if one of the arguments are null
     */
    public static Shape dimensionStripped(Shape shape, Set&lt;? extends Class&lt;?&gt;&gt; dimensionsToStrip) {
<span class="fc" id="L137">        checkNotNull(shape, &quot;shape must not be null&quot;);</span>
<span class="fc" id="L138">        checkNotNull(dimensionsToStrip, &quot;dimensions must not be null&quot;);</span>
<span class="fc" id="L139">        Set&lt;Class&lt;?&gt;&gt; newDimensions = Coordinates.parentClassDifference(shape.dimensionSet(), dimensionsToStrip);</span>
<span class="fc" id="L140">        return Shape.of(newDimensions, Positions</span>
<span class="fc" id="L141">                .unique(transform(shape.positionSet(), toGuavaFunction(Positions.stripping(dimensionsToStrip)))));</span>
    }

    /**
     * Constructs a shape that contains all positions resulting from the outer product of the positions of the left
     * shape with those of the right shape. It is required that the two shapes have no overlap of dimensions (i.e. none
     * of the dimensions in the left shape are available in the right and vice versa).
     * 
     * @param left the left shape to use for the outer product
     * @param right the right shape to use for the outer product
     * @return a shape containing positions constructed from all combinations of the left positions with the right
     *         positions.
     * @throws NullPointerException if one of the arguments is null
     * @throws IllegalArgumentException if the two shapes have overlapping dimensions
     */
    public static Shape outerProduct(Shape left, Shape right) {
<span class="fc" id="L157">        checkArgument(dimensionalIntersection(left, right).isEmpty(), &quot;The two shapes have &quot;</span>
                + &quot;overlapping dimensions. The outer product is not foreseen to be used in this situation.&quot;);
<span class="fc" id="L159">        Shape.Builder builder = Shape.builder(Sets.union(left.dimensionSet(), right.dimensionSet()));</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (Position leftPosition : left.positionSet()) {</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">            for (Position rightPosition : right.positionSet()) {</span>
<span class="fc" id="L162">                builder.add(Positions.union(leftPosition, rightPosition));</span>
<span class="fc" id="L163">            }</span>
<span class="fc" id="L164">        }</span>
<span class="fc" id="L165">        return builder.build();</span>
    }

    /**
     * Checks that both the given arguments are not null and throws exceptions in case they are.
     * 
     * @param left the left shape to check for non-nullity
     * @param right the right shape to check for non-nullity
     * @throws NullPointerException if one of the arguments is {@code null} Fs
     */
    private static void checkLeftRightNotNull(Shape left, Shape right) {
<span class="fc" id="L176">        checkNotNull(left, &quot;left shape must not be null&quot;);</span>
<span class="fc" id="L177">        checkNotNull(right, &quot;right shape must not be null&quot;);</span>
<span class="fc" id="L178">    }</span>

    private static &lt;T, R&gt; com.google.common.base.Function&lt;T, R&gt; toGuavaFunction(Function&lt;T, R&gt; function) {
<span class="fc" id="L181">        return new com.google.common.base.Function&lt;T, R&gt;() {</span>

            @Override
            public R apply(T input) {
<span class="fc" id="L185">                return function.apply(input);</span>
            }
        };
    }

    private static Shape combineLeftRightBy(Shape left, Shape right,
            BiFunction&lt;Set&lt;Position&gt;, Set&lt;Position&gt;, Set&lt;Position&gt;&gt; combiner) {
<span class="fc" id="L192">        checkLeftRightNotNull(left, right);</span>
<span class="pc bpc" id="L193" title="1 of 2 branches missed.">        if (left.dimensionality() != right.dimensionality()) {</span>
<span class="nc" id="L194">            throw new IllegalArgumentException(&quot;Left and right shape do not have the same dimensionality!&quot;);</span>
        }
<span class="fc" id="L196">        Set&lt;Class&lt;?&gt;&gt; dimensionalIntersection = Coordinates.parentClassIntersection(left.dimensionSet(),</span>
<span class="fc" id="L197">                right.dimensionSet());</span>
<span class="fc bfc" id="L198" title="All 2 branches covered.">        if (dimensionalIntersection.size() != left.dimensionality()) {</span>
<span class="fc" id="L199">            throw new IllegalArgumentException(&quot;The shapes are not compatible!&quot;);</span>
        }
<span class="fc" id="L201">        return Shape.of(dimensionalIntersection, combiner.apply(left.positionSet(), right.positionSet()));</span>
    }

    private static Shape combineBy(Iterable&lt;Shape&gt; shapes, BiFunction&lt;Shape, Shape, Shape&gt; combiner) {
<span class="nc" id="L205">        requireNonNull(shapes, &quot;shapes must not be null&quot;);</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (Iterables.isEmpty(shapes)) {</span>
<span class="nc" id="L207">            throw new NoSuchElementException(&quot;At least one shape is required.&quot;);</span>
        }
<span class="nc" id="L209">        Shape resultingShape = null;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        for (Shape shape : shapes) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">            if (resultingShape == null) {</span>
<span class="nc" id="L212">                resultingShape = shape;</span>
            } else {
<span class="nc" id="L214">                resultingShape = combiner.apply(resultingShape, shape);</span>
            }
<span class="nc" id="L216">        }</span>
<span class="nc" id="L217">        return resultingShape;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>